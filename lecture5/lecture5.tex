%% Technological Educational Institute (TEI) of Piraeus
%% School of Engineering, Electronic Computer Systems Department
%% Operating Systems Laboratory, 10 October 2010
%% "Theofilos Papapanagiotou" <theofilos@oslab.teipir.gr>
%% "Michalis Iordanakis" <mdi@oslab.teipir.gr>
%% "Aggelos Karvounis" <akavroun@oslab.teipir.gr>

\section{Σημαφόροι}

Το 1965, ο Dijkstra πρότεινε τη χρήση μιας ακέραιας μεταβλητής για
την καταμέτρηση των σημάτων αφύπνισης που έχουν αποθηκευτεί
για μελλοντική χρήση. Ο νέος τύπος μεταβλητής που παρουσιάστηκε
στην πρότασή του ονομάστηκε σημαφόρος (semaphore) και
αποτελεί ένα μηχανισμό συγχρονισμού διεργασιών για την
αποκλειστική {\bf διαχείριση κοινών πόρων} (π.χ. κοινής μνήμης). Η τιμή
του μπορεί να είναι είτε 0, όταν δεν έχουν αποθηκευτεί σήματα
αφύπνισης, είτε κάποιος θετικός ακέραιος στην περίπτωση που
εκκρεμεί αντίστοιχο πλήθος σημάτων αφύπνισης.

\begin{lstlisting}
A semaphore is a protected variable which can only be
accessed using the following operations:
          P(s)
          Semaphore s;
          {
            while (s == 0) ;  /* wait until s>0 */
            s = s-1;
          }
          V(s)
          Semaphore s;
          {
            s = s+1;
          }
          Init(s, v)
          Semaphore s;
          Int v;
          {
            s = v;
          }
\end{lstlisting}

Ο Dijkstra πρότεινε επίσης δύο εντολές, τις Ρ (Proberen - έλεγχος
στα Ολλανδικά) και V (Verhogen - Αύξηση) που στη συνέχεια για
μνημονικούς λόγους έγιναν down και up αντίστοιχα. Όταν η {\bf down}
επιδρά σε σημαφόρο, ελέγχει αν η τιμή του είναι μεγαλύτερη από 0.
Σε αυτή την περίπτωση, μειώνει την τιμή κατά 1 (χρησιμοποιεί
δηλαδή ένα αποθηκευμένο σήμα αφύπνισης) και απλώς συνεχίζει. Αν
όμως η τιμή του σημαφόρου είναι 0, τότε η καλούσα διεργασία
πέφτει σε λήθαργο χωρίς να ολοκληρώσει μέχρι εκείνη τη στιγμή την
εντολή down.

Ο έλεγχος, η αλλαγή της τιμής, αλλά και η πιθανή απενεργοποίηση
πραγματοποιούνται σε μία και αδιαίρετη ατομική πράξη (atomic
action). Εξασφαλίζεται ότι, από τη στιγμή που ξεκινάει μια εντολή
που εφαρμόζεται σε σημαφόρο, καμία άλλη διεργασία δεν έχει
πρόσβαση σε αυτόν μέχρι την ολοκλήρωση ή την αναστολή της
εντολής. Αυτή η ατομικότητα είναι απολύτως απαραίτητη για την
επίλυση προβλημάτων συγχρονισμού και την αποφυγή συνθηκών
συναγωνισμού.

Η λειτουργία {\bf up} αυξάνει κατά $1$ την τιμή του σημαφόρου στον οποίο
εφαρμόζεται με τη χρήση της κλήσης semop() που θα δούμε παρακάτω . Αν μια ή
περισσότερες διεργασίες είχαν απενεργοποιηθεί μέσω του σημαφόρου αυτού επειδή
δεν μπόρεσαν να ολοκληρώσουν προηγούμενες εντολές down, το σύστημα επιλέγει
κάποια από αυτές με τυχαίο τρόπο, ώστε να ολοκληρώσει την εντολή down από την
οποία έχει μπλοκαριστεί. Συνεπώς, μετά την εφαρμογή μιας εντολής up σε σημαφόρο
που έχει μπλοκάρει κάποιες διεργασίες, αυτός θα συνεχίσει να έχει τιμή $0$,
αλλά οι διεργασίες που βρίσκονται σε λήθαργο και εξαρτώνται από αυτόν θα είναι
κατά μία λιγότερες. Οι εντολές αύξησης του σημαφόρου και αφύπνισης μιας
διεργασίας είναι επίσης αδιαίρετες. Καμία διεργασία δεν μπλοκάρεται κατά τη
διάρκεια της εκτέλεσης της εντολής up.

Συνοψίζοντας τα παραπάνω, γίνεται φανερό πως πριν την είσοδο σε
κρίσιμο τμήμα του προγράμματός της, μία διεργασία ζητά την
απαιτούμενη άδεια από ένα ελεγκτή σημαφόρο (αναμένοντας, αν
χρειάζεται, μέχρι να της δοθεί, οπότε δεσμεύει το απαιτούμενο μέρος
του πόρου που ελέγχει ο σημαφόρος) και μετά την έξοδο από το
κρίσιμο τμήμα αποδεσμεύει το δεσμευμένο μέρος του πόρου. Τέλος,
με τις κλήσεις συστήματος που θα ακολουθήσουν δημιουργούνται
και χρησιμοποιούνται σύνολα από σημαφόρους και ο πυρήνας
εγγυάται ότι ένα σύνολο λειτουργιών επάνω σε ένα τέτοιο σύνολο
σημαφόρων είναι ατομική διαδικασία.\\


\fbox{\parbox{14cm}{
Από τη Βικιπαίδεια, την ελεύθερη εγκυκλοπαίδεια

Στον προγραμματισμό, μια κρίσιμη περιοχή προσδιορίζει ένα τμήμα
κώδικα προγράμματος που μπορεί σε μια δεδομένη χρονική στιγμή
να εκτελεστεί από ακριβώς μία διεργασία. Οι κρίσιμες περιοχές
αποτελούν τμήματα κώδικα που εκτελούνται ατομικά.}}


Υπενθυμίζουμε ότι μια καλή λύση στο πρόβλημα του συγχρονισμού
διεργασιών προϋποθέτει τις ακόλουθες τέσσερις συνθήκες:
\begin{itemize}
 
\item Δυο διεργασίες δεν βρίσκονται ποτέ ταυτόχρονα στις κρίσιμες περιοχές τους.
\item Διεργασία που δεν βρίσκεται σε κρίσιμη περιοχή δεν επιτρέπεται να
αναστείλει άλλες διεργασίες.
\item Δεν επιτρέπεται η επ' αόριστον αναμονή μιας διεργασίας για να εισέλθει
στην κρίσιμη περιοχή της.
\item Δεν επιτρέπονται υποθέσεις σε ότι αφορά την ταχύτητα ή το πλήθος των
επεξεργαστών.
\end{itemize}

\subsection*{Κλήσεις συστήματος σημαφόρων}

Κάθε πρόγραμμα θα πρέπει να περιλαμβάνει τα παρακάτω αρχεία:
\begin{verbatim}
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
\end{verbatim}
Οι βασικότερες κλήσεις είναι οι semget(), semctl() και semop().

\subsection{Κλήση συστήματος semget()}

Η δημιουργία σημαφόρων γίνεται με τη χρήση της συνάρτησης semget(), η οποία
επιστρέφει μία ``ταυτότητα / προσδιοριστή'' για ένα σύνολο από ns σημαφόρους
που αντιστοιχεί στο κλειδί skey και τους οποίους προσδιορίζει μοναδικά.

Η συνάρτηση έχει την μορφή:

\begin{verbatim}
int semget(key_t skey, int ns, int sflag);
\end{verbatim}

Αν η παράμετρος skey έχει τιμή IPC\_PRIVATE, τότε δημιουργείται
ένα καινούργιο (ανώνυμο) σύνολο. Στο sflag τίθενται τα επιθυμητά
δικαιώματα    προστασίας    καθώς   και   πρόσθετες    απαιτήσεις
(IPC\_CREAT, IPC\_EXCL) σχετικές με τη δημιουργία του συνόλου
σημαφόρων.

Στο παράδειγμα που ακολουθεί, υλοποιείται η δημιουργία ενός
σημαφόρου με χρήση της semget().

\lstinputlisting[label=semcreate.c, caption=semcreate.c]{lecture5/semcreate.c}

Μια εκτέλεση του προγράμματος είχε ως αποτέλεσμα:

\begin{verbatim}
Semget succeed! SID=98306
\end{verbatim}

\subsection{Κλήση συστήματος semctl()}

Με τη συνάρτηση semctl(), μπορούν να γίνουν αλλαγές στα
δικαιώματα και σε άλλα χαρακτηριστικά του συνόλου των σημαφόρων. Για παράδειγμα, πριν τερματίσει ένα πρόγραμμα που κάνει
χρήση σημαφόρων, θα πρέπει να αποδεσμεύσει την μνήμη που
καταλαμβάνουν.

Η συνάρτηση συντάσσεται ως εξής:

\begin{verbatim}
int semctl(int sid, int snum, int cmd, union semun arg);
\end{verbatim}

Εκτελεί την ενέργεια cmd στον snum σημαφόρο του συνόλου των
σημαφόρων (ή ανάλογα με την ενέργεια, σε ολόκληρο το σύνολο)
που αντιστοιχεί στον προσδιοριστή sid.

Σε επιτυχία επιστρέφει μια τιμή σχετική με την cmd. Σε αποτυχία
επιστρέφει -1 και θέτει κατάλληλα την τιμή της errno.
Η ένωση union semun χρησιμεύει για να καλύψει όλες τις δυνατότητες ελέγχου, σε οποιοδήποτε σύνολο σημαφόρων και ορίζεται ως:

\begin{verbatim}
union semun {
   int val;
   struct semid_ds *buff;
   unsigned short *array;
};
\end{verbatim}

Μερικές από τις τιμές που μπορεί να πάρει η cmd είναι:
\begin{itemize}
\item SETVAL, με την οποία τίθενται το περιεχόμενο της arg.val ως τιμή του σημαφόρου.
\item GETVAL, με την οποία η semctl() επιστρέφει την τιμή του σημαφόρου.
\item SETALL, με την οποία τίθενται τιμές στο σύνολο των σημαφόρων (από τον πίνακα στην αρχή του οποίου δείχνει το arg.array).
\item GETALL, με την οποία επιστρέφονται οι τιμές των σημαφόρων (στον πίνακα arg.array).
\item IPC\_RMID, με την οποία καταστρέφεται το σύνολο των σημαφόρων.
\item IPC\_STAT, με την οποία συμπληρώνονται τα πεδία της δομής *(arg.buff) με
τα χαρακτηριστικά του συνόλου σημαφόρων.
\end{itemize}
Στο παράδειγμα που ακολουθεί υλοποιείται η δημιουργία ενός μονοσυνόλου
σημαφόρων, σε ένα κλειδί 1234 με χρήση της semget(), ενώ στη συνέχεια γίνεται
αρχικοποίηση του σημαφόρου με χρήση της semctl().

\lstinputlisting[label=semsetup.c, caption=semsetup.c]{lecture5/semsetup.c}

H εκτέλεση του προγράμματος είχε ως αποτέλεσμα:

\begin{verbatim}
Successful creation of semaphore set!
Semaphore ID=98306 on KEY=1234
New Semaphore VALUE=1
\end{verbatim}

Επίσης, με χρήση της τιμής IPC\_RMID, στη cmd της semctl(),
επιτυγχάνεται η διαγραφή ενός συνόλου σημαφόρων από τη μνήμη.
Στο επόμενο παράδειγμα, υλοποιείται η αποδέσμευση της μνήμης
από το μονοσύνολο σημαφόρων που δημιουργήθηκε στο Πρόγραμμα \ref{semdelete.c}.
Προφανώς, αν δεν έχει προηγηθεί η δημιουργία του συνόλου των σημαφόρων από την
εκτέλεση του συγκεκριμένου παραδείγματος, η προσπάθεια διαγραφής που
υλοποιείται θα οδηγηθεί σε αποτυχία.

\lstinputlisting[label=semdelete.c, caption=semdelete.c]{lecture5/semdelete.c}

H εκτέλεση του προγράμματος είχε ως αποτέλεσμα:

\begin{verbatim}
Semaphore ID=196610 on KEY=1234
Successful semaphore deletion!
\end{verbatim}

Ενώ μια ακόμη προσπάθεια εκτέλεσης είχε ως αποτέλεσμα:

\begin{verbatim}
semget: No such file or directory
\end{verbatim}

\subsection{Κλήση συστήματος semop()}

Οι λειτουργίες up() και down() που περιγράφηκαν πιο πάνω,
υλοποιούνται μέσω κλήσεων στην semop(), η οποία έχει την
παρακάτω μορφή:
\begin{verbatim}
int semop(int sid, struct sembuf *opstr, int nops);
\end{verbatim}
Η συγκεκριμένη κλήση εκτελεί στο σύνολο σημαφόρων που προσδιορίζονται από το
sid, τις λειτουργίες που καθορίζονται σε ένα πίνακα μεγέθους nops από δομές struct
sembuf, το πρώτο στοιχείο του οποίου δείχνει το opstr. Η δομή struct sembuf
ορίζεται ως εξής:

\begin{verbatim}
struct sembuf {
   short snum;
   short sop;
   short sflag;
};
\end{verbatim}

Η παραπάνω δομή περιγράφει τη μεταβολή της τιμής του υπ'
αριθμόν snum σημαφόρου, από τους ns (0 εώς ns-1) σημαφόρους
του συνόλου, κατά sop ($<0$ για δέσμευση και $>0$ για αποδέσμευση).
Συγκεκριμένα, η sop πρέπει να είναι -1 αν ενδιαφερόμαστε για την
λειτουργία της down() και +1 αν ενδιαφερόμαστε για την up().
Το sflag το θέτουμε συνήθως 0, εκτός ειδικών περιπτώσεων.

Στο παράδειγμα που ακολουθεί υλοποιείται η χρήση των λειτουργιών
δέσμευση και αποδέσμευση του στόχου που αντιστοιχεί στο κλειδί
1234, του μονοσυνόλου σημαφόρων που δημιουργήθηκαν στο
Πρόγραμμα \ref{semsetup.c}, με χρήση της semop(). Για το λόγο
αυτό η εκτέλεση του, πρέπει να έπεται της εκτέλεσης του
Προγράμματος \ref{semsetup.c}.

\lstinputlisting[label=semoperations.c,
caption=semoperations.c]{lecture5/semoperations.c}


Η εκτέλεση του προγράμματος είχε ως αποτέλεσμα:
\begin{verbatim}
Grap hold of semaphore with SID=98306 and KEY=1234,
created by semSetUp.c
< < < Press ENTER to block the target > > >
\end{verbatim}
Πατώντας ENTER, δεσμεύεται ο στόχος που αντιστοιχεί στο κλειδί:
\begin{verbatim}
Trying to block the target...
Blocked!!!
\end{verbatim}
Όταν ο στόχος είναι δεσμευμένος, καμιά άλλη διεργασία δεν μπορεί
να δεσμεύσει τον ίδιο στόχο. Πατώντας όμως για δεύτερη φορά
ENTER, αποδεσμεύεται και τότε είναι διαθέσιμος προς νέα δέσμευση:
\begin{verbatim}
< < < Press ENTER to unblock > > >
Unblocked!
\end{verbatim}
Το επόμενο παράδειγμα είναι ένα απλό πρόγραμμα, που υλοποιεί το
μοντέλο παραγωγού/καταναλωτή με δύο διεργασίες:

\lstinputlisting[label=semproducerconsumer.c,
caption=semproducerconsumer.c]{lecture5/semproducerconsumer.c}

Στο πρόγραμμα που ακολουθεί, παρουσιάζεται η χρήση δέσμευσης
και αποδέσμευσης ενός σημαφόρου που συγχρονίζει την πρόσβαση
πολλαπλών διεργασιών σε κοινό αρχείο.

Πριν την προσπέλαση στο αρχείο, χρησιμοποιούμε την semop() για
δέσμευση του σημαφόρου. Η τιμή -1 στην sem\_op.sem\_op σημαίνει
ότι, αν η τιμή του σημαφόρου είναι ίση ή μεγαλύτερη με 1, αυτή θα
μειωθεί κατά 1 και ο έλεγχος θα επιστρέψει στην καλούσα διεργασία.
Διαφορετικά, θα ανασταλεί η καλούσα διεργασία, μέχρι η τιμή του
σημαφόρου να γίνει 1. Μετά την προσπέλαση στο αρχείο, αυξάνεται
η τιμή του σημαφόρου κατά 1. Αν περιμένουν περισσότερες διεργα-
σίες για το σημαφόρο, θα αφυπνιστεί η πρώτη που αναστάλθηκε και
θα συνεχίσει την επεξεργασία.

\lstinputlisting[label=semfilemutex.c,
caption=semfilemutex.c]{lecture5/semfilemutex.c}

Η εκτέλεση του προγράμματος είχε ως αποτέλεσμα:
\begin{verbatim}
5371
5371
5371
5372
5372
5373
5372
5373
5373
5374
5374
5374
5375
5375
5375
main: all done
\end{verbatim}
και το αρχείο test.dat θα έχει περιεχόμενο 5375.
