%% Technological Educational Institute (TEI) of Piraeus
%% School of Engineering, Electronic Computer Systems Department
%% Operating Systems Laboratory, 10 October 2010
%% "Theofilos Papapanagiotou" <theofilos@oslab.teipir.gr>
%% "Michalis Iordanakis" <mdi@oslab.teipir.gr>
%% "Aggelos Karvounis" <akavroun@oslab.teipir.gr>

\section{Διεργασίες}

Η πιο σημαντική έννοια σε όλα τα λειτουργικά συστήματα, είναι η
διεργασία (process). Μια διεργασία είναι ένα πρόγραμμα που
εκτελείται ή πιο σωστά μια αφαιρετική θεώρηση ενός προγράμματος
που εκτελείται.

Κάθε διεργασία στο Unix συνοδεύεται από:
\begin{itemize}
  \item[] ένα αριθμό ταυτότητας (PID-Process IDentity),
  \item[] μια λίστα θέσεων μνήμης που καλείται χώρος διευθύνσεων
      (address space), στον οποίο περιέχονται ο κώδικας της, τα
      δεδομένα της και μια στοίβα,
  \item[] καταχωρητές στους οποίους περιλαμβάνονται ο μετρητής
      προγράμματος, ο δείκτης της στοίβας και καταχωρητές υλικού,
  \item[] καθώς και κάποια άλλα χαρακτηριστικά. 
\end{itemize}
Με την εντολή ps, μπορούμε να δούμε τις διεργασίες που τρέχουν
στο σύστημα:

\begin{verbatim}
$ ps
 PID TTY   TIME CMD
8880 pts/2 0:00 ps
8876 pts/2 0:00 bash
\end{verbatim}

Προσέξτε πως η πρώτη διεργασία είναι η εντολή ps με pid=8880,
ενώ η δεύτερη είναι ο φλοιός που αποτελεί επίσης διεργασία και έχει
pid=8876.

Μητρική διεργασία όλων, είναι η init με PID=1 και κάθε άλλη
διεργασία, θεωρείται απόγονος της.

Μοναδικός τρόπος για να δημιουργηθεί μια διεργασία, είναι κάποια άλλη να
αναπαράγει τον εαυτό της, δηλαδή μια γονική διεργασία να γεννήσει μια διεργασία παιδί.
Τότε, η γονική διεργασία κληροδοτεί τον κώδικα, τα δεδομένα και τη στοίβα της,
στη διεργασία παιδί της, δηλαδή είναι αντίγραφα αυτών της γονικής διεργασίας.
Όμως, η ταυτότητα της διεργασίας παιδιού είναι διαφορετική από την ταυτότητα της
γονικής διεργασίας, όπως φαίνεται και στο επόμενο παράδειγμα:

\begin{verbatim}
$ ps -f
     UID  PID  PPID C   STIME TTY   TIME CMD
guest123 8881 8876 0 19:57:34 pts/2 0:00 ps -f
guest123 8876 8874 0 19:57:08 pts/2 0:00 -bash
\end{verbatim}

Με την εντολή ps -f, μπορούμε να δούμε τις διεργασίες που τρέχουν
στο σύστημα, με περισσότερες πληροφορίες γι' αυτές, όπως το UID
του χρήστη που την προκάλεσε, τον αριθμό ταυτότητας της (PID),
τον αριθμό ταυτότητας της γονικής-διεργασίας (PPID) κ.λ.π.
Προσέξτε πως οι ταυτότητες PID και PPID διαφέρουν και πως η
διεργασία ps -f , έχει γονική τη -bash, δηλαδή το φλοιό.

Μια διεργασία-παιδί μπορεί να αντικαταστήσει τον κώδικα, τα
δεδομένα και τη στοίβα της με αυτά ενός εκτελέσιμου αρχείου,
διαφοροποιώντας έτσι τον εαυτό της από τον πατέρα της.

\subsection{Κλήσεις συστήματος για τη διαχείριση διεργασιών}

\subsubsection{Κλήση συστήματος exit()}

Η εκτέλεση μιας διεργασίας τερματίζει με την κλήση συστήματος
exit. Η συνάρτηση έχει την παρακάτω μορφή:

\begin{verbatim}
void exit(int status)
\end{verbatim}

Στον ακέραιο status, που ονομάζεται κωδικός εξόδου (exit code), η
γονική-διεργασία μπορεί να βρεί τον ακέραιο αριθμό με τον οποίο
τερματίστηκε η διεργασία-παιδί. Γενικά, η τιμή 0 στον status,
δηλώνει επιτυχή τερματισμό.

\subsubsection{Κλήσεις συστήματος getpid() και getppid()}

Κλήσεις συστήματος getpid() και getppid()
Η κλήση συστήματος getpid(), επιστρέφει τον αριθμό ταυτότητας
(PID) της τρέχουσας διεργασίας, ενώ η getppid(), επιστρέφει τον
αριθμό ταυτότητας (PPID) της γονικής-διεργασίας. Οι συναρτήσεις
έχουν ως εξής:

\begin{verbatim}
int getpid()
int getppid()
\end{verbatim}

Το παράδειγμα που ακολουθεί, εμφανίζει τον αριθμό ταυτότητας της
τρέχουσας διεργασίας (πρόγραμμα pids.c) και της γονικής-
διεργασίας (φλοιός -bash). Τέλος, τερματίζει επιστρέφοντας ως κωδικό
εξόδου τον ακέραιο 27, στη γονική-διεργασία, δηλαδή το φλοιό.

\lstinputlisting[caption=pids.c]{lecture1/pids.c}

Η εκτέλεση του προγράμματος θα μας δώσει:

\begin{verbatim}
I am the process with PID=8984
and my parent PID=8969
\end{verbatim}

Όπου εμφανίζοντας τις διεργασίες, παρατηρούμε πως το πρόγραμμα
μας έχει γονική-διεργασία το φλοιό (PID=8969):

\begin{verbatim}
$ ps -f
      UID    PID   PPID   C    STIME TTY       TIME CMD
guest123    8985   8969   0 23:58:01 pts/2     0:00 ps -f
guest123    8969   8967   0 23:52:36 pts/2     0:00 -bash
\end{verbatim}

Επίσης, μπορούμε να εμφανίσουμε από τη γονική-διεργασία (δηλαδή
το φλοιό) και τον κωδικό εξόδου του προγράμματος:

\begin{verbatim}
$ echo $?
27
\end{verbatim}

\subsubsection{Κλήση συστήματος fork()}

O μοναδικός τρόπος δημιουργίας μιας νέας διεργασίας στο UNIX,
είναι με την κλήση συστήματος fork. Η συνάρτηση δημιουργίας
διεργασίας έχει την παρακάτω μορφή:

\begin{verbatim}
int fork()
\end{verbatim}

Η $fork()$ δημιουργεί νέες διεργασίες, αντίγραφα της αρχικής διεργασίας (η οποία
περιλαμβάνει τους περιγραφείς αρχείων, τους καταχωρητές και όλα τα υπόλοιπα),
που εκτελούν το ίδιο πρόγραμμα με τη γονική διεργασία και μάλιστα αρχίζοντας από
το σημείο που κλήθηκε η fork.

Μετά την κλήση της fork(), οι δύο διεργασίες (γονική και παιδί)
συνήθως ακολουθούν διαφορετικές πορείες. Έτσι οι τιμές των
μεταβλητών των δύο διεργασιών, που μέχρι εκείνη τη στιγμή ήταν
πανομοιότυπες, στη συνέχεια διαφοροποιούνται ανεξάρτητα για την
κάθε διεργασία.

Ο μόνος τρόπος για να διακρίνουμε σε ποιά διεργασία βρισκόμαστε,
ώστε να προσδιορίσουμε την εξέλιξη της, είναι η τιμή που επιστρέφει
η fork(). Στη διεργασία-παιδί είναι 0, ενώ στη γονική είναι ίση με
την ταυτότητα (process identity) της διεργασίας-παιδί. Σε περίπτωση
που δεν είναι δυνατόν να δημιουργηθεί η διεργασία-παιδί, η fork()
επιστρέφει -1 στη γονική-διεργασία.

Στο παράδειγμα που ακολουθεί, υλοποιείται η δημιουργία μιας
διεργασίας-παιδί από τη γονική-διεργασία. Κάθε μια τους, δίνει την
ταυτότητά της καθώς και την ταυτότητα της γονικής της και
τερματίζει εκτελώντας κοινό κώδικα.

\lstinputlisting[caption=fork1.c]{lecture1/fork1.c}

Η εκτέλεση του προγράμματος θα μας δώσει:

\begin{verbatim}
Creating new process!!!
PA: I am the parent
PA: and i have PID = 23851
PA: but i have a PPID=23841, too !!! 
CH: I am the child
Bye from 23851 ... 
CH: and i have PID=23852.
CH: My PPID=23851 !!!
Bye from 23852 ... 
\end{verbatim}

Μια διεργασία-παιδί τερματίζει, επιστρέφοντας ένα κωδικό εξόδου
στη γονική της. Όταν η διεργασία-παιδί τερματίσει αλλά για κάποιο
λόγο η γονική της δεν είναι σε θέση να αποδεχτεί τον κωδικό εξόδου
της, τότε η διεργασία-παιδί παραμένει ζωντανή-νεκρή (zombie),
μέχρι να μπορέσει η γονική της να αποδεχτεί τον κωδικό εξόδου της.

Στο παράδειγμα που ακολουθεί, υλοποιείται η δημιουργία μιας
διεργασίας-παιδί από τη γονική-διεργασία. Κάθε μια τους, δίνει την
ταυτότητά της καθώς και την ταυτότητα της γονικής της και
τερματίζει εκτελώντας κοινό κώδικα.

\lstinputlisting[caption=fork2.c]{lecture1/fork2.c}

Έτσι, η διεργασία-παιδί είναι ζωντανή-νεκρή και ο μόνος τρόπος για
να τερματίσει, είναι ο τερματισμός της γονικής. Για να γίνει όμως
αυτό, πρέπει να ξανασυνδεθούμε στο σύστημα, να βρούμε τη
συγκεκριμένη διεργασία και να δώσουμε: kill pid (όπου pid ο αριθμός
ταυτότητας της).

\subsubsection{Κλήση συστήματος wait()}

Η κλήση συστήματος wait, προκαλεί την αναμονή της γονικής διεργασίας, μεχρις
ότου τερματιστεί η διεργασία-παιδί (ή οποιαδήποτε διεργασία-παιδί της, αν έχει περισσότερα του ενός). Η
συνάρτηση έχει την παρακάτω μορφή:

\begin{verbatim}
int wait(int *status)
\end{verbatim}

Μόλις η wait ολοκληρωθεί, τοποθετείται η τιμή του κωδικού εξόδου
της διεργασίας-παιδιού δηλαδή ο ακέραιος της εντολής exit, στο αριστερό byte του status, ενώ το δεξί είναι 0.

Η wait επιστρέφει τον ακέραιο -1 στην περίπτωση που η διεργασία
για κάποιο λόγο δεν έχει παιδιά ή τον ακέραιο αριθμό ταυτότητας της
διεργασίας-παιδιού που τερμάτισε.

Τα παραπάνω υλοποιούνται στο παράδειγμα που ακολουθεί:

\lstinputlisting[caption=wait.c]{lecture1/wait.c}

Η εκτέλεση του προγράμματος θα μας δώσει:

\begin{verbatim}
I am the child. That's all.
I am the parent and
my child terminated with code 5
\end{verbatim}

Πρέπει να σημειώσουμε τη σύνθετη λειτουργία της συνθήκης της
εντολής if. Η fork() αρχικά δημιουργεί τη διεργασία-παιδί αλλά
ταυτόχρονα επιστρέφει και ένα ακέραιο που αν είναι 0, αντιστοιχεί
στον κώδικα της διεργασίας-παιδιού που εκτελείται. Επίσης, στην
τελευταία printf(), προσέξτε πως για να εμφανίσουμε τον κωδικό
εξόδου της διεργασίας παιδί, προκαλούμε 8 θέσεων κύληση (shift)
προς τα δεξιά, για να πάρουμε το τμήμα που αντιστοιχεί στον
συγκεκριμένο κωδικό.

Σημειώνουμε πως υπάρχουν κι άλλες εκδοχές της wait (π.χ. η
waitpid και η wait4), στις οποίες μπορούν να προσδιοριστούν και
διάφορες άλλες επιλογές όπως προσδιορισμός της διεργασίας της
οποίας αναμένεται ο τερματισμός κ.α.

\subsubsection{Κλήσεις συστήματος της ομάδας exec()}

Οι κλήσεις συστήματος της ομάδας exec, χρησιμοποιούνται προκειμένου μια
δεργασία παιδί, που δημιουργήθηκε από τη fork, να αντικαταστήσει τον κώδικά
της, με ένα νέο πρόγραμμα το οποίο θέλουμε να εκτελεστεί.

Όπως φαίνεται στη παρακάτω εικόνα, η διεργασία-παιδί αντικαθιστά
τον παλιό κώδικα με νέο πρόγραμμα, που συνήθως διαφέρει από
αυτό που εκτελεί η γονική-διεργασία.

Υπάρχουν αρκετές διαδικασίες βιβλιοθήκης της οικογένειας exec.
Από αυτές επιλέξαμε τις επόμενες τέσσερεις μορφές:

\begin{verbatim}
int execl(const char *path, const char *arg, ...,
                                    char *argn, NULL);
int execlp(const char *file, const char *arg, ...,
                                    char *argn, NULL);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
\end{verbatim}

Όπως βλέπουμε, όλες επιστρέφουν ένα ακέραιο, ο οποίος σε
περίπτωση λάθους (αδύνατη εύρεση του εκτελέσιμου αρχείου) είναι
το -1. Σε περίπτωση επιτυχίας, ποτέ δεν επιστρέφουν.
Το τελευταίο όρισμα για τις execl/execlp και το argv[n+1] για τις
execv/execvp, πρέπει πάντα να είναι NULL. Το πρώτο όρισμα
(path), για τις execl/execv παίρνει το απόλυτο ή σχετικό όνομα-
μονοπάτι, ενώ στις άλλες δύο τη μεταβλητή περιβάλλοντος PATH,
για την εύρεση του εκτελέσιμου αρχείου. Στα υπόλοιπα ορίσματα
βάζουμε τις διάφορες παραμέτρους εισόδου που απαιτούνται.

H execl() υλοποιείται στο παράδειγμα που ακολουθεί:

\lstinputlisting[caption=execl.c]{lecture1/execl.c}

Η εκτέλεση του προγράμματος θα μας δώσει:

\begin{verbatim}
Child:PID=9204 - PPID= 9203
      UID    PID PPID C         STIME TTY  TIME  CMD
guest123 9203 9191 0 07:45:40 pts/2        0:00  ./execl
guest123 9204 9203 0 07:45:40 pts/2        0:00  ps -f
guest123 9191 9189 0 07:44:47 pts/2        0:00  -sh
I am parent process with PID=9203
My job is a ps list
    PID TTY       TIME CMD
  9203 pts/2      0:00 ps
  9191 pts/2      0:00 sh
\end{verbatim}

Πρέπει να σημειώσουμε τη σύνθετη λειτουργία της συνθήκης της
τελευταίας εντολής if, όπου εκτός από την κλήση της execl(), γίνεται
και έλεγχος λάθους, πράγμα αδύνατο στην περίπτωση αυτή. Η fork()
αρχικά δημιουργεί τη διεργασία-παιδί και αν δεν καταφέρει να
δημιουργήσει τη διεργασία-παιδί, επιστρέφει -1 και εκτελείται η
συνάρτηση λάθους perror().

H execvp() υλοποιείται στο παράδειγμα που ακολουθεί:


\lstinputlisting[caption=execvp.c]{lecture1/execvp.c}


Η εκτέλεση του προγράμματος θα μας δώσει:

\begin{verbatim}
Child process:
total 24
-rwxr-xr-x 1 guest   users 7932 Μάρ 4 10:59 duplicate1
-rw-r--r-- 1 guest   users  326 Μάρ 4 10:59 duplicate1.c
-rw-r--r-- 1 guest   users    0 Μάρ 4 12:32 emptyfile
I am the parent and
my child terminated  with code 0
\end{verbatim}

Αξίζει να σημειώσουμε οτι η διεργασία-παιδί μετά την επιτυχή
εκτέλεση της $execvp()$, σωστά δεν καταφέρνει να φτάσει στην
επιστροφή του 5 ως κωδικό εξόδου.

